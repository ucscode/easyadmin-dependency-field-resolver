<?php

namespace Ucscode\EasyAdmin\DependencyFieldResolver\EventListener;

use EasyCorp\Bundle\EasyAdminBundle\Event\BeforeCrudActionEvent;
use Symfony\Component\EventDispatcher\EventDispatcherInterface;
use Symfony\Component\EventDispatcher\EventSubscriberInterface;
use Symfony\Component\HttpFoundation\RedirectResponse;
use Symfony\Component\HttpFoundation\Response;
use Ucscode\EasyAdmin\DependencyFieldResolver\Dto\DataDto;
use Ucscode\EasyAdmin\DependencyFieldResolver\Event\DependencyChangedEvent;
use Ucscode\EasyAdmin\DependencyFieldResolver\Service\DependencyFieldResolver;
use Ucscode\EasyAdmin\DependencyFieldResolver\Service\ResolverDataBridge;

class DependencyStateListener implements EventSubscriberInterface
{
    public function __construct(
        private ResolverDataBridge $bridge,
        private EventDispatcherInterface $eventDispatcher,
    ) {
    }

    public static function getSubscribedEvents(): array
    {
        return [
            BeforeCrudActionEvent::class => 'onBeforeCrudAction',
        ];
    }

    public function onBeforeCrudAction(BeforeCrudActionEvent $event): void
    {
        $context = $event->getAdminContext();
        $request = $context->getRequest();

        // We only care about POST requests (form submissions)
        if (!$request->isMethod('POST')) {
            return;
        }

        $entityDto = $context->getEntity();
        $formName = $entityDto->getName();
        $postData = $request->request->all($formName);

        // Retrieve the state signature generated by the Resolver
        $encodedState = $postData[DependencyFieldResolver::RESOLVER_STATE] ?? null;
        if (!$encodedState) {
            return;
        }

        $renderedState = json_decode(base64_decode($encodedState), true);
        if (!is_array($renderedState)) {
            return;
        }

        if ($this->hasStateChanged($renderedState, $postData)) {
            // 1. Prepare Data & Response
            $postDataDto = new DataDto($postData);
            $response = new RedirectResponse($request->getUri(), Response::HTTP_SEE_OTHER);

            // 2. Initialize Event
            $stateEvent = new DependencyChangedEvent($context, $postDataDto, $response);

            // 3. Dispatch (New Signature)
            // Listeners can now modify $postDataDto or the $response object inside $stateEvent
            $this->eventDispatcher->dispatch($stateEvent);

            // 4. Capture the (potentially modified) data into our Bridge
            $this->bridge->persist($stateEvent->getPostData()->all());

            // 5. Apply the final Response
            // We pull the response from the EVENT, not the local variable,
            // in case a listener called $event->setResponse(...)
            $event->setResponse($stateEvent->getResponse());
        }
    }

    /**
     * Checks if any monitored parent field has a different value than when the form was rendered.
     */
    private function hasStateChanged(array $renderedState, array $postData): bool
    {
        foreach ($renderedState as $fieldName => $oldValue) {
            $newValue = $postData[$fieldName] ?? null;

            // Simple comparison for strings/numbers.
            // If the value changed, the form structure is now technically "stale".
            if ($newValue !== $oldValue) {
                return true;
            }
        }

        return false;
    }
}
