<?php

namespace Ucscode\EasyAdmin\DependencyFieldResolver\EventListener;

use EasyCorp\Bundle\EasyAdminBundle\Event\BeforeCrudActionEvent;
use Symfony\Component\EventDispatcher\EventDispatcherInterface;
use Symfony\Component\EventDispatcher\EventSubscriberInterface;
use Symfony\Component\HttpFoundation\RedirectResponse;
use Ucscode\EasyAdmin\DependencyFieldResolver\Dto\DataDto;
use Ucscode\EasyAdmin\DependencyFieldResolver\Event\DependencyChangedEvent;
use Ucscode\EasyAdmin\DependencyFieldResolver\Service\DependencyFieldResolver;
use Ucscode\EasyAdmin\DependencyFieldResolver\Service\ResolverDataBridge;

class DependencyStateListener implements EventSubscriberInterface
{
    public function __construct(
        private ResolverDataBridge $bridge,
        private EventDispatcherInterface $eventDispatcher,
    ) {
    }

    public static function getSubscribedEvents(): array
    {
        return [
            BeforeCrudActionEvent::class => 'onBeforeCrudAction',
        ];
    }

    public function onBeforeCrudAction(BeforeCrudActionEvent $event): void
    {
        $context = $event->getAdminContext();
        $request = $context->getRequest();

        // We only care about POST requests (form submissions)
        if (!$request->isMethod('POST')) {
            return;
        }

        $entityDto = $context->getEntity();
        $formName = $entityDto->getName();
        $postData = $request->request->all($formName);

        // Retrieve the state signature generated by the Resolver
        $encodedState = $postData[DependencyFieldResolver::RESOLVER_STATE] ?? null;
        if (!$encodedState) {
            return;
        }

        $renderedState = json_decode($encodedState, true);
        if (!is_array($renderedState)) {
            return;
        }

        // Compare the "Rendered" state with the "Current" submitted values
        if ($this->hasStateChanged($renderedState, $postData)) {
            // Create PostDataDto
            $postDataDto = new DataDto($postData);

            $response = new RedirectResponse($request->getUri());
            $stateEvent = new DependencyChangedEvent($context, $postDataDto, $response);

            $this->eventDispatcher->dispatch($stateEvent);
            // 1. Capture the data into our Bridge (Session)
            $this->bridge->persist($postDataDto->all());

            // 2. Redirect back to the same page
            // This prevents Symfony from validating the mismatched form
            $event->setResponse($stateEvent->getResponse());
        }
    }

    /**
     * Checks if any monitored parent field has a different value than when the form was rendered.
     */
    private function hasStateChanged(array $renderedState, array $postData): bool
    {
        foreach ($renderedState as $fieldName => $oldValue) {
            $newValue = $postData[$fieldName] ?? null;

            // Simple comparison for strings/numbers.
            // If the value changed, the form structure is now technically "stale".
            if ($newValue !== $oldValue) {
                return true;
            }
        }

        return false;
    }
}
